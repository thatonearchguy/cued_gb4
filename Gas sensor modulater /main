
# Tasks: Read analog signal, plot real-time response, measure peak, decay, duration, and compute statistics

import serial
import time
import matplotlib.pyplot as plt
import numpy as np

# --- Configuration ---
PORT = 
BAUDRATE = 9600
DURATION = 10  
SAMPLING_INTERVAL = 

ser = serial.Serial('', 9600)  

while True:
    data = ser.readline().decode().strip()
    print(f"Sensor Value: {data}")


# --- Connect to Arduino ---
ser = serial.Serial(PORT, BAUDRATE, timeout=1)
time.sleep(2)  # Wait for Arduino to reset

# --- Data Acquisition ---
timestamps = []
sensor_values = []
start_time = time.time()

print("Reading sensor data...")
while time.time() - start_time < DURATION:
    line = ser.readline().decode('utf-8').strip()
    try:
        value = float(line)
        current_time = time.time() - start_time
        timestamps.append(current_time)
        sensor_values.append(value)
    except ValueError:
        continue
    time.sleep(SAMPLING_INTERVAL)

ser.close()
print("Done.")

# --- Convert to NumPy arrays ---
timestamps = np.array(timestamps)
sensor_values = np.array(sensor_values)

# --- Plot sensor response ---
plt.figure(figsize=(10, 5))
plt.plot(timestamps, sensor_values, label='MQ3 Output')
plt.xlabel('Time (s)')
plt.ylabel('Sensor Value (ADC)')
plt.title('MQ3 Sensor Real-Time Response')
plt.legend()
plt.grid(True)
plt.show()

# --- Feature Extraction ---
def analyze_sensor_response(time_data, sensor_data):
    peak_value = np.max(sensor_data)
    time_to_peak = time_data[np.argmax(sensor_data)]

    # Estimate time to return near baseline
    baseline = np.median(sensor_data[:int(0.1 * len(sensor_data))])
    threshold = baseline + 0.05 * (peak_value - baseline)
    decay_time = None
    for i in range(np.argmax(sensor_data), len(sensor_data)):
        if sensor_data[i] < threshold:
            decay_time = time_data[i] - time_to_peak
            break

    # Duration above threshold
    activity_indices = np.where(sensor_data > threshold)[0]
    duration = (activity_indices[-1] - activity_indices[0]) / (1/SAMPLING_INTERVAL) if len(activity_indices) > 0 else 0

    energy = np.trapz(sensor_data, dx=SAMPLING_INTERVAL)

    return {
        'peak': peak_value,
        'time_to_peak': time_to_peak,
        'decay_time': decay_time,
        'duration': duration,
        'energy': energy
    }

# --- Compute & Print Results ---
results = analyze_sensor_response(timestamps, sensor_values)
print("\nSensor Response Summary:")
for k, v in results.items():
    print(f"{k}: {v:.2f}")